// index.js
require('dotenv').config();
const { Client, LocalAuth } = require('whatsapp-web.js');
const express = require('express');
const bodyParser = require('body-parser');
const qrcode = require('qrcode');
const sqlite3 = require('sqlite3').verbose();
const fs = require('fs');
const { createClient } = require('@deepgram/sdk');
const vision = require('@google-cloud/vision');
const PDFParser = require('pdf-parse');
const schedule = require('node-schedule');
const os = require('os');
const winston = require('winston');
const path = require('path');
const axios = require('axios');

const logger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.printf(({ timestamp, level, message }) => `${timestamp} [${level}]: ${message}`)
    ),
    transports: [
        new winston.transports.File({ filename: 'logs/bot.log', maxsize: 5 * 1024 * 1024, maxFiles: 5, tailable: true }),
        new winston.transports.Console()
    ]
});

const metrics = require('./utils/metrics');

logger.info('InÃ­cio da aplicaÃ§Ã£o');

const app = express();
app.use(bodyParser.json());

const config = JSON.parse(fs.readFileSync('./config.json', 'utf-8') || '{}');
const defaultConfig = {
    autoReply: true,
    reportTime: '0 0 * * *',
    weeklyReportTime: '0 0 * * 0',
    maxRetries: 5,
    rateLimitMs: 1000,
    apiTimeout: 15000,
    reconnectInterval: 10000,
    maxReconnectAttempts: Infinity,
    cacheTTL: 24 * 60 * 60 * 1000,
    cpuThreshold: 80,
    memoryThreshold: 80,
    commandsPerMinute: 10,
    adminNumber: process.env.ADMIN_PHONE_NUMBER || 'SEU_NUMERO_ADMIN',
    maintenanceMessage: 'âš ï¸ ManutenÃ§Ã£o programada em breve. Pode haver interrupÃ§Ãµes.',
    maintenanceTime: process.env.MAINTENANCE_TIME || null,
    monitoredGroups: [process.env.GROUP_ID || 'GGx81qcrRp33sFF6RLpuCd'],
    maxWitAITrainingPerHour: 10,
    maxWitAICallsPerMinute: 5 // Limite de chamadas ao Wit.ai por minuto
};
Object.assign(config, defaultConfig, config);

const TIMEZONE_OFFSET = process.env.TIMEZONE_OFFSET ? parseInt(process.env.TIMEZONE_OFFSET) : -3;

const startTime = Date.now();
const rateLimitMap = new Map();
const conversationContext = new Map();
const witAICallCount = { count: 0, lastReset: Date.now() };

const plugins = {};
const loadPlugins = async () => {
    const pluginDir = path.join(__dirname, 'plugins');
    const files = await fs.promises.readdir(pluginDir);
    for (const file of files) {
        if (file.endsWith('.js')) {
            const pluginName = file.replace('.js', '');
            plugins[pluginName] = require(path.join(pluginDir, file));
            logger.info(`Plugin carregado: ${pluginName}`);
        }
    }
};
loadPlugins();

const products = {
    "CÃ©rebro em Alta Performance": {
        keywords: ["desempenho cerebral", "foco", "memÃ³ria", "saÃºde mental", "cansaÃ§o mental", "produtividade", "mente saudÃ¡vel", "clareza mental", "concentraÃ§Ã£o", "raciocÃ­nio", "fadiga mental", "esquecimento", "lentidÃ£o mental", "excesso de trabalho", "neblina mental", "dificuldade de foco", "saÃºde neuronal"],
        questions: [
            "VocÃª jÃ¡ sentiu que sua mente tÃ¡ mais lenta ou esquecendo coisas ultimamente?",
            "O cansaÃ§o mental tÃ¡ te atrapalhando no trabalho ou nos estudos?"
        ],
        campaignMessages: {
            formal: "Com base no que vocÃª me disse, o *CÃ©rebro em Alta Performance* pode transformar sua vida! Ele melhora a concentraÃ§Ã£o, fortalece a memÃ³ria e elimina o cansaÃ§o mental com tÃ©cnicas simples e cientÃ­ficas. Quer dar esse passo? Clica aqui: [link]",
            informal: "Pelo teu papo, o *CÃ©rebro em Alta Performance* Ã© perfeito pra ti, mano! Teu foco vai pro espaÃ§o (no bom sentido!), a memÃ³ria fica tinindo e o cansaÃ§o mental vira passado. Clica aqui agora: [link]"
        },
        link: "https://renovacaocosmica.shop/23/crb-fnl",
        description: "Um e-book revolucionÃ¡rio que revela os segredos para otimizar o funcionamento do cÃ©rebro e alcanÃ§ar alta performance mental. Baseado em estudos cientÃ­ficos, oferece tÃ©cnicas prÃ¡ticas para melhorar a saÃºde cerebral, aumentar a concentraÃ§Ã£o, fortalecer a memÃ³ria e promover clareza mental. Ideal para quem quer uma mente afiada e uma vida saudÃ¡vel."
    },
    "Corpo e Mente": {
        keywords: ["equilÃ­brio emocional", "estresse", "saÃºde do corpo", "bem-estar", "saÃºde mental", "cansaÃ§o", "mente equilibrada", "recuperaÃ§Ã£o emocional", "ansiedade", "tensÃ£o", "harmonia", "esgotamento", "nervosismo", "burnout", "dores", "exaustÃ£o"],
        questions: [
            "VocÃª anda sentindo muito estresse ou um peso no corpo ultimamente?",
            "TÃ¡ precisando de algo pra dar uma equilibrada na vida?"
        ],
        campaignMessages: {
            formal: "Pelo que vocÃª contou, o *Corpo e Mente* Ã© ideal pra vocÃª! Ele reduz o estresse, harmoniza corpo e mente e te deixa mais leve com mÃ©todos naturais. Quer experimentar? Clica aqui: [link]",
            informal: "Com esse teu relato, o *Corpo e Mente* te salva, mano! Zera o estresse, deixa tudo em harmonia e te dÃ¡ um gÃ¡s novo. Corre pro link: [link]"
        },
        link: "https://renovacaocosmica.shop/23/crpint-fnl",
        description: "Um guia completo para restaurar o equilÃ­brio fÃ­sico e emocional com mÃ©todos naturais e eficazes. Combina prÃ¡ticas simples para reduzir o estresse, melhorar a saÃºde emocional e revitalizar o corpo, ideal para quem busca harmonia e bem-estar sem medicamentos."
    },
    "SaÃºde Imersiva": {
        keywords: ["saÃºde tecnolÃ³gica", "dispositivos vestÃ­veis", "realidade aumentada", "monitoramento de saÃºde", "bem-estar", "tecnologia de saÃºde", "prevenÃ§Ã£o", "saÃºde moderna", "inovaÃ§Ã£o", "saÃºde em tempo real"],
        questions: [
            "VocÃª jÃ¡ pensou em monitorar sua saÃºde com tecnologia de ponta?",
            "Quer ter o controle total do teu bem-estar na palma da mÃ£o?"
        ],
        campaignMessages: {
            formal: "Com o que vocÃª me disse, o *SaÃºde Imersiva* Ã© perfeito pra vocÃª! Monitore sua saÃºde em tempo real com dispositivos modernos e viva melhor. Clica aqui pra conhecer: [link]",
            informal: "Pelo teu papo, o *SaÃºde Imersiva* Ã© o teu lance! Te dÃ¡ o controle da saÃºde com tech foda, mano. Clica aqui: [link]"
        },
        link: "https://renovacaocosmica.shop/23/fnl-imersiva",
        description: "Um guia que explora o futuro da saÃºde com dispositivos vestÃ­veis e realidade aumentada. Permite monitoramento em tempo real, personalizaÃ§Ã£o de metas de bem-estar e prevenÃ§Ã£o de doenÃ§as, trazendo a revoluÃ§Ã£o tecnolÃ³gica para o cuidado pessoal."
    },
    "SaÃºde do AmanhÃ£": {
        keywords: ["tecnologia de saÃºde", "diagnÃ³sticos precoces", "tratamentos personalizados", "saÃºde futura", "inovaÃ§Ã£o mÃ©dica", "prevenÃ§Ã£o de doenÃ§as", "saÃºde avanÃ§ada", "monitoramento", "ciÃªncia da saÃºde"],
        questions: [
            "JÃ¡ imaginou ter diagnÃ³sticos super precisos antes de qualquer problema aparecer?",
            "Quer usar a tecnologia pra cuidar da tua saÃºde como nunca?"
        ],
        campaignMessages: {
            formal: "Com base no que vocÃª falou, o *SaÃºde do AmanhÃ£* Ã© a soluÃ§Ã£o pra vocÃª! DiagnÃ³sticos precisos e tratamentos personalizados com tecnologia de ponta. Clica aqui: [link]",
            informal: "Pelo que tu disse, o *SaÃºde do AmanhÃ£* Ã© o teu futuro, mano! DiagnÃ³sticos certeiros e cuidados top com tech avanÃ§ada. Clica aqui: [link]"
        },
        link: "https://renovacaocosmica.shop/23/fnl-saude",
        description: "Um programa que apresenta tecnologias inovadoras para cuidar da saÃºde, como diagnÃ³sticos precoces e tratamentos personalizados. Ideal para quem quer estar Ã  frente das tendÃªncias e usar a ciÃªncia a favor do bem-estar."
    },
    "Sono Profundo, Vida Renovada": {
        keywords: ["sono profundo", "qualidade do sono", "noites mal dormidas", "cansaÃ§o diurno", "recuperaÃ§Ã£o", "descanso", "energia", "regeneraÃ§Ã£o", "insÃ´nia", "sono reparador"],
        questions: [
            "VocÃª tem acordado cansado ou com dificuldade pra dormir?",
            "TÃ¡ precisando de um sono que te deixe renovado?"
        ],
        campaignMessages: {
            formal: "Com o que vocÃª me contou, o *Sono Profundo, Vida Renovada* Ã© perfeito pra vocÃª! Melhore seu sono e sinta-se renovado com tÃ©cnicas simples. Clica aqui: [link]",
            informal: "Pelo teu papo, o *Sono Profundo* te salva, mano! Dorme bem pra caramba e acorda novo em folha. Clica aqui: [link]"
        },
        link: "https://renovacaocosmica.shop/23/sono-fnl",
        description: "Um programa para alcanÃ§ar um sono profundo e reparador, essencial para a recuperaÃ§Ã£o fÃ­sica e mental. Inclui tÃ©cnicas prÃ¡ticas para criar uma rotina de sono que melhora a energia e a saÃºde geral."
    },
    "Rosa Xantina": {
        keywords: ["pele radiante", "saÃºde da pele", "linhas finas", "renovaÃ§Ã£o celular", "melasma", "espinhas", "elasticidade", "sebo", "hidrataÃ§Ã£o", "pele jovem", "dermatologia"],
        questions: [
            "VocÃª jÃ¡ reparou em linhas finas ou manchas na pele que te incomodam?",
            "Quer uma pele mais firme e bonita sem esforÃ§o?"
        ],
        campaignMessages: {
            formal: "Com base no que vocÃª disse, o *Rosa Xantina* Ã© ideal pra vocÃª! Reduz linhas finas, hidrata e deixa sua pele radiante. Clica aqui pra experimentar: [link]",
            informal: "Pelo teu relato, o *Rosa Xantina* Ã© o teu segredo, mano! Linhas finas somem e a pele fica top. Clica aqui: [link]"
        },
        link: "https://ev.braip.com/ref?pv=pro9y44w&af=afijp7y0qm",
        description: "Um produto inovador com fÃ³rmula poderosa para uma pele radiante e saudÃ¡vel. Desenvolvido por especialistas, reduz linhas finas, minimiza manchas e melhora a elasticidade, oferecendo resultados visÃ­veis desde as primeiras aplicaÃ§Ãµes."
    },
    "Os Alongamentos Essenciais": {
        keywords: ["flexibilidade", "tensÃµes musculares", "postura", "relaxamento", "dores musculares", "alongamentos", "saÃºde fÃ­sica", "bem-estar", "rotina diÃ¡ria"],
        questions: [
            "VocÃª sente o corpo travado ou com dores depois de um dia longo?",
            "Quer melhorar tua postura e relaxar com algo simples?"
        ],
        campaignMessages: {
            formal: "Com o que vocÃª me disse, os *Alongamentos Essenciais* sÃ£o perfeitos pra vocÃª! Alivie tensÃµes e ganhe flexibilidade em 15 minutos por dia. Clica aqui: [link]",
            informal: "Pelo teu papo, os *Alongamentos Essenciais* te ajudam, mano! Tira a tensÃ£o e deixa o corpo leve em 15 minutinhos. Clica aqui: [link]"
        },
        link: "https://renovacaocosmica.shop/23/alg-fnl",
        description: "Um guia com alongamentos simples para fazer em casa em apenas 15 minutos diÃ¡rios. Alivia tensÃµes musculares, melhora a flexibilidade e promove relaxamento fÃ­sico e mental."
    },
    "Renavidiol CBA": {
        keywords: ["beleza da pele", "hidrataÃ§Ã£o", "rugas", "pÃ© de galinha", "bigode chinÃªs", "firmeza", "brilho", "pele macia", "juventude", "canabinoides"],
        questions: [
            "VocÃª jÃ¡ notou rugas ou quer uma pele mais firme e hidratada?",
            "TÃ¡ afim de se sentir mais jovem com uma pele top?"
        ],
        campaignMessages: {
            formal: "Com base no teu relato, o *Renavidiol CBA* Ã© perfeito pra vocÃª! Hidrata na hora, reduz rugas e deixa a pele firme e brilhante. Clica aqui: [link]",
            informal: "Pelo que tu falou, o *Renavidiol CBA* Ã© o teu lance, mano! Pele hidratada, rugas fora e brilho total. Clica aqui: [link]"
        },
        link: "https://ev.braip.com/ref?pv=pro173dg&af=afimex7zn1",
        description: "Um produto com tecnologia Canabinoid Active Systemâ„¢ que restaura a beleza da pele em poucas aplicaÃ§Ãµes. Oferece hidrataÃ§Ã£o instantÃ¢nea, reduz rugas e devolve firmeza e brilho."
    },
    "Nervocure": {
        keywords: ["dores crÃ´nicas", "neuropatia", "ciÃ¡tica", "formigamentos", "dormÃªncia", "queimaÃ§Ã£o", "inflamaÃ§Ã£o", "sistema nervoso", "alÃ­vio", "nervo ciÃ¡tico", "desconforto"],
        questions: [
            "VocÃª tem sentido dores, formigamentos ou queimaÃ§Ã£o que nÃ£o passam?",
            "TÃ¡ cansado de desconforto nas pernas ou nas mÃ£os?"
        ],
        campaignMessages: {
            formal: "Com o que vocÃª me contou, o *Nervocure* Ã© ideal pra vocÃª! Alivia dores e regenera os nervos de forma natural e segura. Clica aqui: [link]",
            informal: "Pelo teu papo, o *Nervocure* te livra das dores, mano! Acaba com formigamento e queimaÃ§Ã£o rapidinho. Clica aqui: [link]"
        },
        link: "https://renovacaocosmica.shop/23/nervocuretic",
        description: "Uma soluÃ§Ã£o natural e segura para aliviar dores crÃ´nicas e desconfortos nervosos, como neuropatias e ciÃ¡tica. Regenera o sistema nervoso e melhora a qualidade de vida."
    },
    "100Queda (Trinoxidil Americano)": {
        keywords: ["queda de cabelo", "folÃ­culos", "cabelo forte", "calvÃ­cie", "trinoxidil", "restauraÃ§Ã£o capilar", "estimuladores capilares", "autoestima", "cabelo ralo"],
        questions: [
            "VocÃª tÃ¡ preocupado com a queda de cabelo ou cabelo ralo?",
            "Quer recuperar teus fios e ter cabelo forte de novo?"
        ],
        campaignMessages: {
            formal: "Com base no que vocÃª disse, o *100Queda* Ã© a soluÃ§Ã£o pra vocÃª! Restaura atÃ© 2.000 fios por semana com tecnologia americana. Clica aqui: [link]",
            informal: "Pelo teu relato, o *100Queda* te salva, mano! Para a queda e traz teu cabelo de volta com forÃ§a. Clica aqui: [link]"
        },
        link: "https://ev.braip.com/ref?pv=pro4rxm7&af=afivpggv51",
        description: "Um tratamento revolucionÃ¡rio que restaura atÃ© 2.000 fios de cabelo por semana. Com fÃ³rmula americana, paralisa a queda, revive folÃ­culos e fortalece os fios sem efeitos colaterais."
    },
    "HemoGotas": {
        keywords: ["hemorroidas", "alÃ­vio rÃ¡pido", "tecnologia americana", "desconforto", "saÃºde natural", "inflamaÃ§Ã£o", "dor anal", "bem-estar"],
        questions: [
            "VocÃª tÃ¡ sofrendo com hemorroidas ou desconforto por aÃ­?",
            "Quer se livrar desse problema de vez e sem dor?"
        ],
        campaignMessages: {
            formal: "Com o que vocÃª me disse, o *HemoGotas* Ã© perfeito pra vocÃª! AlÃ­vio rÃ¡pido e natural pras hemorroidas com tecnologia avanÃ§ada. Clica aqui: [link]",
            informal: "Pelo teu papo, o *HemoGotas* resolve teu rolÃª, mano! Acaba com as hemorroidas rapidinho e sem stress. Clica aqui: [link]"
        },
        link: "https://ev.braip.com/ref?pv=pror2eex&af=afilxjyn16",
        description: "Um tratamento natural com tecnologia americana que combate hemorroidas de dentro para fora. Oferece alÃ­vio rÃ¡pido e seguro, eliminando o desconforto e restaurando a qualidade de vida."
    }
};

const db = new sqlite3.Database('./groupMessages.db', sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE, (err) => {
    if (err) logger.error('Erro ao conectar ao SQLite:', err.message);
    else logger.info('Conectado ao banco SQLite.');
});

(async () => {
    try {
        await Promise.all([
            new Promise((resolve, reject) => db.run(`CREATE TABLE IF NOT EXISTS messages (id INTEGER PRIMARY KEY AUTOINCREMENT, groupId TEXT, date TEXT, message TEXT)`, (err) => err ? reject(err) : resolve())),
            new Promise((resolve, reject) => db.run(`CREATE TABLE IF NOT EXISTS knowledge (id INTEGER PRIMARY KEY AUTOINCREMENT, userId TEXT, date TEXT, content TEXT)`, (err) => err ? reject(err) : resolve())),
            new Promise((resolve, reject) => db.run(`CREATE TABLE IF NOT EXISTS leads (id INTEGER PRIMARY KEY AUTOINCREMENT, userId TEXT, date TEXT, message TEXT, followedUp INTEGER DEFAULT 0)`, (err) => err ? reject(err) : resolve())),
            new Promise((resolve, reject) => db.run(`CREATE TABLE IF NOT EXISTS cache (id INTEGER PRIMARY KEY AUTOINCREMENT, prompt TEXT UNIQUE, response TEXT, date TEXT)`, (err) => err ? reject(err) : resolve())),
            new Promise((resolve, reject) => db.run(`CREATE TABLE IF NOT EXISTS usage (id INTEGER PRIMARY KEY AUTOINCREMENT, userId TEXT, command TEXT, date TEXT)`, (err) => err ? reject(err) : resolve())),
            new Promise((resolve, reject) => db.run(`CREATE TABLE IF NOT EXISTS connection_logs (id INTEGER PRIMARY KEY AUTOINCREMENT, event TEXT, timestamp TEXT, details TEXT)`, (err) => err ? reject(err) : resolve()))
        ]);
        logger.info('Tabelas SQLite inicializadas com sucesso.');
    } catch (err) {
        logger.error('Erro ao inicializar tabelas SQLite:', err.message);
        process.exit(1);
    }
})();

const deepgram = process.env.DEEPGRAM_API_KEY ? createClient(process.env.DEEPGRAM_API_KEY) : null;
const visionClient = process.env.GOOGLE_VISION_API_KEY ? new vision.ImageAnnotatorClient({ key: process.env.GOOGLE_VISION_API_KEY }) : null;

let qrCodeData = '';
let initializationError = null;
let client = null;
let isClientReady = false;

async function logConnectionEvent(event, details) {
    const timestamp = new Date().toISOString();
    return new Promise((resolve) => {
        db.run('INSERT INTO connection_logs (event, timestamp, details) VALUES (?, ?, ?)', [event, timestamp, details], (err) => {
            if (err) logger.error(`Erro ao logar evento de conexÃ£o: ${err.message}`);
            resolve(!err);
        });
    });
}

function monitorResources() {
    const cpuUsage = os.loadavg()[0] / os.cpus().length * 100;
    const totalMem = os.totalmem();
    const freeMem = os.freemem();
    const usedMem = (totalMem - freeMem) / totalMem * 100;

    if (cpuUsage > config.cpuThreshold || usedMem > config.memoryThreshold) {
        const alertMessage = `ðŸš¨ Alerta de Recursos:\nCPU: ${cpuUsage.toFixed(2)}% (limite: ${config.cpuThreshold}%)\nMemÃ³ria: ${usedMem.toFixed(2)}% (limite: ${config.memoryThreshold}%)`;
        logger.warn(alertMessage);
        if (config.adminNumber && client) client.sendMessage(config.adminNumber, alertMessage);
    }
}

function scheduleDatabaseBackup() {
    schedule.scheduleJob('0 2 * * *', async () => {
        const backupPath = `./backup/groupMessages_${new Date().toISOString().split('T')[0]}.db`;
        try {
            await fs.promises.copyFile('./groupMessages.db', backupPath);
            logger.info(`Backup criado com sucesso em ${backupPath}`);
        } catch (err) {
            logger.error(`Erro ao criar backup: ${err.message}`);
        }
    });
}

async function manualBackup() {
    const backupPath = `./backup/groupMessages_manual_${new Date().toISOString().replace(/:/g, '-')}.db`;
    try {
        await fs.promises.copyFile('./groupMessages.db', backupPath);
        logger.info(`Backup manual criado em ${backupPath}`);
        return backupPath;
    } catch (err) {
        logger.error(`Erro ao criar backup manual: ${err.message}`);
        throw err;
    }
}

function scheduleMaintenanceNotification() {
    if (!config.maintenanceTime) return;
    schedule.scheduleJob(config.maintenanceTime, async () => {
        try {
            for (const groupId of config.monitoredGroups) {
                await client.sendMessage(groupId, config.maintenanceMessage);
            }
            logger.info('NotificaÃ§Ã£o de manutenÃ§Ã£o enviada para todos os grupos.');
        } catch (error) {
            logger.error(`Erro ao enviar notificaÃ§Ã£o de manutenÃ§Ã£o: ${error.message}`);
        }
    });
}

function scheduleSalesRecovery() {
    schedule.scheduleJob('0 */3 * * *', async () => {
        const threeHoursAgo = new Date(Date.now() - 3 * 60 * 60 * 1000).toISOString();
        db.all('SELECT id, userId, message FROM leads WHERE followedUp = 0 AND date < ?', [threeHoursAgo], async (err, rows) => {
            if (err) {
                logger.error('Erro ao verificar leads para recuperaÃ§Ã£o de vendas:', err.message);
                return;
            }
            for (const row of rows) {
                try {
                    const campaign = identifyCampaign(row.message);
                    const tone = detectTone(row.message);
                    let recoveryMessage = campaign && products[campaign].campaignMessages
                        ? products[campaign].campaignMessages[tone].replace('[link]', products[campaign].link)
                        : `Oi de novo! Notei que vocÃª mencionou "${row.message}" hÃ¡ um tempo. Ainda tÃ¡ precisando de ajuda com isso?`;
                    const product = findRelevantProduct(row.message);
                    if (product) recoveryMessage += `\n\nOlha sÃ³: ${product.description} Clique AGORA e resolve de vez: ${product.link}`;
                    
                    await client.sendMessage(row.userId, adjustTone(recoveryMessage, tone));
                    await markLeadAsFollowedUp(row.id);
                    logger.info(`Mensagem de recuperaÃ§Ã£o de vendas enviada para ${row.userId}: ${recoveryMessage}`);
                } catch (error) {
                    logger.error(`Erro ao enviar recuperaÃ§Ã£o de vendas para ${row.userId}: ${error.message}`, error.stack);
                }
            }
        });
    });
    logger.info('RecuperaÃ§Ã£o de vendas agendada para a cada 3 horas.');
}

const port = process.env.PORT || 3000;
app.get('/', (req, res) => {
    logger.info('Rota raiz acessada');
    if (initializationError) res.status(500).send(`Erro ao iniciar o bot WhatsApp: ${initializationError.message}`);
    else if (!isClientReady) res.status(200).send('Bot WhatsApp estÃ¡ iniciando ou reconectando...');
    else res.status(200).send('Bot WhatsApp estÃ¡ ativo!');
});

app.get('/health', (req, res) => {
    res.status(isClientReady ? 200 : 503).json({
        status: isClientReady ? 'healthy' : 'unhealthy',
        uptime: Math.floor((Date.now() - startTime) / 1000 / 60),
        messageCount: metrics.getMessageCount(),
        lastError: initializationError ? initializationError.message : null,
        cpuUsage: (os.loadavg()[0] / os.cpus().length * 100).toFixed(2),
        memoryUsage: ((os.totalmem() - os.freemem()) / os.totalmem() * 100).toFixed(2)
    });
});

app.listen(port, () => {
    logger.info(`Servidor Express rodando na porta ${port}`);
    initializeWhatsAppClient();
    schedule.scheduleJob('*/5 * * * *', monitorResources);
    scheduleDatabaseBackup();
    scheduleMaintenanceNotification();
    scheduleSalesRecovery();
});

function initializeWhatsAppClient() {
    logger.info('Inicializando cliente WhatsApp');
    const isWindows = process.platform === 'win32';
    const chromiumPath = isWindows ? null : (process.env.PUPPETEER_EXECUTABLE_PATH || '/usr/bin/chromium');

    try {
        client = new Client({
            authStrategy: new LocalAuth({ dataPath: isWindows ? './whatsapp-auth' : '/data/whatsapp-auth' }),
            puppeteer: {
                headless: true,
                executablePath: chromiumPath,
                args: [
                    '--no-sandbox',
                    '--disable-setuid-sandbox',
                    '--disable-dev-shm-usage',
                    '--disable-accelerated-2d-canvas',
                    '--no-first-run',
                    '--no-zygote',
                    '--disable-gpu',
                    '--aggressive-cache-discard',
                    '--disable-cache',
                    '--disable-extensions',
                    '--disable-background-networking'
                ],
                timeout: 120000,
            },
            webVersionCache: {
                type: 'remote',
                remotePath: 'https://raw.githubusercontent.com/wppconnect-team/wa-version/main/html/2.2412.54.html'
            }
        });

        setupClientEvents();
        startClient();
    } catch (err) {
        logger.error('Erro ao criar instÃ¢ncia do cliente WhatsApp:', err.message, err.stack);
        initializationError = err;
        scheduleReconnect();
    }
}

async function getBotResponse(prompt, context) {
    const userId = context.userId;
    const tone = detectTone(prompt);
    const history = context.history || [];
    const sentiment = analyzeSentiment(prompt);

    // Verificar cache primeiro
    const cachedResponse = await getFromCache(prompt);
    if (cachedResponse) {
        logger.info(`Resposta recuperada do cache: ${cachedResponse}`);
        return adjustTone(cachedResponse, tone);
    }

    // Consultar conhecimento existente
    const knowledge = await getKnowledge(userId);
    if (knowledge) {
        const knowledgeLines = knowledge.split('\n');
        for (const line of knowledgeLines) {
            const [key, value] = line.split(':').map(s => s.trim().toLowerCase());
            if (prompt.toLowerCase().includes(key)) {
                const response = adjustTone(`Pelo que eu aprendi, ${value}. Isso te ajuda ou quer saber mais?`, tone);
                await saveToCache(prompt, response);
                return response;
            }
        }
    }

    // Respostas prÃ©-definidas para saudaÃ§Ãµes e perguntas comuns
    const greetings = ["oi", "olÃ¡", "e aÃ­", "opa", "bom dia", "boa tarde", "boa noite"];
    if (greetings.some(g => prompt.toLowerCase().startsWith(g))) {
        const lastMessage = history.length > 1 ? history[history.length - 2].content : '';
        if (greetings.some(g => lastMessage.toLowerCase().includes(g))) {
            return adjustTone("Oi de novo! Como posso te ajudar dessa vez?", tone);
        }
        return adjustTone("Oi, tudo bem? Como posso te ajudar hoje?", tone);
    } else if (prompt.match(/^(o que vocÃª faz|o que vocÃª pode fazer|como vocÃª ajuda)$/i)) {
        return adjustTone("Eu sou teu parceiro pra tudo! Posso te ajudar com saÃºde mental, dores, pele, cabelo, sono e muito mais. SÃ³ me diz o que tÃ¡ rolando contigo ou pergunta qualquer coisa!", tone);
    } else if (prompt.match(/^(tudo bem|como vocÃª tÃ¡|como vocÃª estÃ¡)$/i)) {
        return adjustTone("TÃ´ de boa, valeu por perguntar! E tu, como tÃ¡ se sentindo hoje?", tone);
    } else if (prompt.match(/^(obrigado|valeu|agradeÃ§o)$/i)) {
        return adjustTone("Por nada, fico feliz em ajudar! Tem mais alguma coisa que eu possa fazer por ti?", tone);
    }

    // Detectar produto relevante e seguir fluxo de vendas
    const product = findRelevantProduct(prompt);
    if (product && !context.product) {
        context.product = product;
        context.step = 1;
        const response = adjustTone(`Parece que vocÃª tÃ¡ precisando de uma mÃ£ozinha. ${product.questions[0]}`, tone);
        await saveToCache(prompt, response);
        return response;
    } else if (context.product && context.step === 1) {
        context.step = 2;
        const response = adjustTone(`Entendi, parece que isso tÃ¡ te afetando mesmo. ${context.product.questions[1]}`, tone);
        await saveToCache(prompt, response);
        return response;
    } else if (context.product && context.step === 2) {
        const response = adjustTone(context.product.campaignMessages[tone].replace('[link]', context.product.link) + `\n\n${context.product.description}`, tone);
        await saveLead(userId, prompt);
        context.step = 0;
        context.product = null;
        await saveToCache(prompt, response);
        return response;
    }

    // Resposta contextual com base no histÃ³rico
    if (history.length > 0) {
        const lastUserMessage = history.find(msg => msg.role === 'user')?.content || '';
        if (lastUserMessage && !prompt.match(/^(sim|nÃ£o|talvez)$/i)) {
            const response = adjustTone(`Sobre o que tu disse antes ("${lastUserMessage}"), como eu posso te ajudar mais com "${prompt}"?`, tone);
            await saveToCache(prompt, response);
            return response;
        } else if (prompt.match(/^(sim|nÃ£o|talvez)$/i)) {
            const response = adjustTone(prompt === 'sim' ? "Beleza, entÃ£o vamos resolver isso! O que mais tu quer saber?" : 
                                       prompt === 'nÃ£o' ? "Ok, sem problema. O que tÃ¡ rolando contigo entÃ£o?" : 
                                       "TÃ¡ indeciso, hein? Me conta mais pra eu te dar uma luz!", tone);
            await saveToCache(prompt, response);
            return response;
        }
    }

    // Usar Wit.ai para respostas criativas ou desconhecidas
    if (process.env.WITAI_API_TOKEN && canCallWitAI()) {
        try {
            const inputText = history.length > 0 ? `${history.map(msg => `${msg.role === 'user' ? 'VocÃª' : 'Eu'}: ${msg.content}`).join('\n')}\nVocÃª: ${prompt}` : prompt;
            const response = await axios.get(
                `https://api.wit.ai/message?v=20250305&q=${encodeURIComponent(inputText)}`,
                { headers: { 'Authorization': `Bearer ${process.env.WITAI_API_TOKEN}` }, timeout: config.apiTimeout }
            );
            const intents = response.data.intents || [];
            let result;
            if (intents.length > 0) {
                result = adjustTone(`Entendi que vocÃª quer falar sobre "${intents[0].name}". Me conta mais pra eu te ajudar direitinho!`, tone);
            } else {
                // Solicitar IA para gerar resposta criativa
                result = await axios.post(
                    'https://api.wit.ai/message?v=20250305',
                    { q: `Gere uma resposta Ãºtil e natural em portuguÃªs para: "${inputText}"` },
                    { headers: { 'Authorization': `Bearer ${process.env.WITAI_API_TOKEN}` } }
                ).then(res => res.data.text || adjustTone("Hmm, nÃ£o sei direito como te ajudar com isso ainda. Me explica mais ou me ensina algo sobre isso?", tone));
            }
            witAICallCount.count++;
            await saveToCache(prompt, result);
            if (canTrainWitAI()) await trainWitAI(inputText, intents[0]?.name || 'unknown');
            logger.info(`Resposta gerada com Wit.ai: ${result}`);
            return result;
        } catch (error) {
            logger.error(`Erro ao usar Wit.ai: ${error.message}`);
        }
    }

    // Fallback final com tom humano
    const fallbacks = [
        "Hmm, nÃ£o sei direito como te ajudar com isso. Me conta mais pra eu entender melhor?",
        "TÃ´ tentando te ajudar, mas fiquei perdido aqui. Pode explicar mais ou perguntar outra coisa?",
        "Ops, nÃ£o peguei essa ainda. Me dÃ¡ mais detalhes que eu te ajudo direitinho!"
    ];
    const fallback = adjustTone(fallbacks[Math.floor(Math.random() * fallbacks.length)], tone);
    await saveToCache(prompt, fallback);
    return fallback;
}

async function trainWitAI(prompt, intentName) {
    const now = Date.now();
    if (now - witAICallCount.lastReset > 3600000) {
        witAICallCount.count = 0;
        witAICallCount.lastReset = now;
    }
    if (witAICallCount.count >= config.maxWitAITrainingPerHour) return;
    try {
        await axios.post(
            'https://api.wit.ai/utterances?v=20250305',
            [{ text: prompt, intent: intentName, entities: [], traits: [] }],
            { headers: { 'Authorization': `Bearer ${process.env.WITAI_API_TOKEN}` } }
        );
        witAICallCount.count++;
        logger.info(`Wit.ai treinado com "${prompt}" para intent "${intentName}"`);
    } catch (error) {
        logger.error(`Erro ao treinar Wit.ai: ${error.message}`);
    }
}

function canTrainWitAI() {
    const now = Date.now();
    if (now - witAICallCount.lastReset > 3600000) {
        witAICallCount.count = 0;
        witAICallCount.lastReset = now;
    }
    return witAICallCount.count < config.maxWitAITrainingPerHour;
}

function canCallWitAI() {
    const now = Date.now();
    if (now - witAICallCount.lastReset > 60000) {
        witAICallCount.count = 0;
        witAICallCount.lastReset = now;
    }
    return witAICallCount.count < config.maxWitAICallsPerMinute;
}

function setupClientEvents() {
    client.on('loading_screen', (percent, message) => {
        if (isClientReady) return;
        logger.info(`Carregando WhatsApp: ${percent}% - ${message}`);
    });

    client.on('qr', (qr) => {
        qrCodeData = qr;
        logger.info('QR gerado com sucesso! Acesse /qr para escanear.');
        logConnectionEvent('qr_generated', 'Novo QR Code gerado');
    });

    client.on('authenticated', () => {
        logger.info(`SessÃ£o autenticada com sucesso. Dados salvos em ${process.platform === 'win32' ? './whatsapp-auth' : '/data/whatsapp-auth'}.`);
        logConnectionEvent('authenticated', 'SessÃ£o autenticada');
    });

    client.on('ready', async () => {
        isClientReady = true;
        logger.info('Bot conectado e pronto para uso.');
        console.log('Bot conectado no Fly!');
        logConnectionEvent('ready', 'Cliente conectado');
        const reportNumber = process.env.REPORT_PHONE_NUMBER;
        if (reportNumber) await client.sendMessage(reportNumber, 'Bot conectado no Fly! ðŸš€');
        scheduleDailyReport();
        scheduleWeeklyReport();
        scheduleLeadFollowUps();
        try {
            await client.getChats();
            logger.info('Chats sincronizados com sucesso.');
        } catch (err) {
            logger.error('Erro ao sincronizar chats:', err.message);
        }
    });

    client.on('auth_failure', (message) => {
        logger.error('Falha na autenticaÃ§Ã£o:', message);
        initializationError = new Error(`Falha na autenticaÃ§Ã£o: ${message}`);
        logConnectionEvent('auth_failure', message);
        scheduleReconnect();
    });

    client.on('disconnected', (reason) => {
        isClientReady = false;
        logger.warn(`Cliente desconectado: ${reason}`);
        logConnectionEvent('disconnected', `Motivo: ${reason}`);
        scheduleReconnect();
    });

    client.on('change_state', (state) => {
        logger.info(`Estado do cliente alterado: ${state}`);
        logConnectionEvent('state_change', state);
    });

    client.on('message', async (message) => {
        logger.info(`Mensagem recebida de ${message.from}: ${message.body}`);
        try {
            metrics.logMessage();
            const userId = message.from;
            const text = message.body.toLowerCase();
            const lang = detectLanguage(text);
            const sentiment = analyzeSentiment(text);
            const isGroup = userId.endsWith('@g.us');

            const now = Date.now();
            const userRate = rateLimitMap.get(userId) || { count: 0, lastReset: now };
            if (now - userRate.lastReset > 60000) {
                userRate.count = 0;
                userRate.lastReset = now;
            }

            if (text.startsWith('!')) {
                if (userRate.count >= config.commandsPerMinute) {
                    await client.sendMessage(userId, adjustTone('Calma aÃ­, vocÃª tÃ¡ indo rÃ¡pido demais! Aguarde um minutinho! â³', detectTone(text)));
                    return;
                }
                userRate.count++;
                rateLimitMap.set(userId, userRate);
                await handleCommand(text, message, lang, sentiment);
            } else if (isGroup) {
                logger.debug(`Mensagem ignorada em grupo ${userId}: ${text}`);
                return;
            } else if (message.hasMedia) {
                await handleMediaMessage(message, lang);
            } else if (config.autoReply) {
                let context = conversationContext.get(userId) || { history: [], step: 0, product: null, userId };
                context.history.push({ role: 'user', content: message.body });
                if (context.history.length > 5) context.history.shift();

                const response = await getBotResponse(message.body, context);
                const finalResponse = await adjustResponseBasedOnSentiment(response, sentiment);
                context.history.push({ role: 'assistant', content: finalResponse });
                conversationContext.set(userId, context);

                await client.sendMessage(userId, finalResponse);
            }
        } catch (error) {
            logger.error(`Erro ao processar mensagem de ${message.from}: ${error.message}`, error.stack);
            await client.sendMessage(message.from, adjustTone('Ops, deu um probleminha aqui! Tenta de novo, vai?', detectTone(message.body || '')));
        }
    });

    app.get('/qr', async (req, res) => {
        logger.info('Rota /qr acessada');
        if (!qrCodeData) {
            if (initializationError) return res.status(500).send(`Erro ao gerar o QR Code: ${initializationError.message}. Tentando reconectar...`);
            return res.send('QR nÃ£o gerado ainda. Aguarde ou reinicie o bot.');
        }
        try {
            const qrImage = await qrcode.toDataURL(qrCodeData);
            res.send(`<img src="${qrImage}" alt="Escaneie este QR Code com o WhatsApp" />`);
        } catch (error) {
            logger.error('Erro ao gerar imagem QR:', error.message, error.stack);
            res.status(500).send('Erro ao gerar o QR Code. Tente novamente.');
        }
    });
}

function startClient() {
    client.initialize()
        .then(() => {
            logger.info('Cliente WhatsApp inicializado com sucesso!');
            initializationError = null;
        })
        .catch((err) => {
            logger.error('Erro ao inicializar o cliente WhatsApp:', err.message, err.stack);
            initializationError = err;
            scheduleReconnect();
        });
}

function scheduleReconnect() {
    let attempts = 0;
    const baseDelay = config.reconnectInterval;

    const reconnect = () => {
        if (attempts >= config.maxReconnectAttempts && config.maxReconnectAttempts !== Infinity) {
            logger.error('NÃºmero mÃ¡ximo de tentativas de reconexÃ£o atingido. Encerrando processo.');
            process.exit(1);
        }

        const delay = Math.min(baseDelay * Math.pow(2, attempts), 60000);
        logger.info(`Tentativa ${attempts + 1} de reconexÃ£o em ${delay / 1000} segundos...`);
        
        setTimeout(() => {
            if (!client) {
                initializeWhatsAppClient();
            } else {
                client.destroy().then(() => {
                    initializeWhatsAppClient();
                }).catch((err) => {
                    logger.error('Erro ao destruir cliente para reconexÃ£o:', err.message);
                    initializeWhatsAppClient();
                });
            }
        }, delay);

        attempts++;
    };

    reconnect();
}

setInterval(() => {
    if (!isClientReady && client) {
        logger.warn('Cliente nÃ£o estÃ¡ pronto. Verificando estado...');
        scheduleReconnect();
    }
    logger.debug('Keep-alive: Mantendo o processo ativo...');
}, 30000);

async function saveGroupMessage(groupId, message) {
    const date = new Date().toISOString().split('T')[0];
    return new Promise((resolve, reject) => {
        db.get('SELECT COUNT(*) as count FROM messages WHERE groupId = ? AND date = ?', [groupId, date], (err, row) => {
            if (err) return reject(err);
            if (row.count >= 1000) {
                logger.warn(`Limite de mensagens atingido para o grupo ${groupId} na data ${date}.`);
                return resolve(false);
            }
            db.run('INSERT INTO messages (groupId, date, message) VALUES (?, ?, ?)', [groupId, date, JSON.stringify(message)], (err) => {
                if (err) reject(err);
                else resolve(true);
            });
        });
    });
}

async function saveKnowledge(userId, content) {
    const date = new Date().toISOString().split('T')[0];
    return new Promise((resolve, reject) => {
        db.run('INSERT INTO knowledge (userId, date, content) VALUES (?, ?, ?)', [userId, date, content], (err) => {
            if (err) reject(err);
            else resolve(true);
        });
    });
}

async function getKnowledge(userId) {
    return new Promise((resolve, reject) => {
        db.all('SELECT content FROM knowledge WHERE userId = ?', [userId], (err, rows) => {
            if (err) reject(err);
            else resolve(rows.map(row => row.content).join('\n'));
        });
    });
}

async function saveLead(userId, message) {
    const date = new Date().toISOString();
    return new Promise((resolve, reject) => {
        db.run('INSERT INTO leads (userId, date, message) VALUES (?, ?, ?)', [userId, date, message], (err) => {
            if (err) reject(err);
            else resolve(true);
        });
    });
}

async function getLeads(userId) {
    return new Promise((resolve, reject) => {
        db.all('SELECT date, message FROM leads WHERE userId = ?', [userId], (err, rows) => {
            if (err) reject(err);
            else resolve(rows.map(row => `${row.date}: ${row.message}`).join('\n'));
        });
    });
}

async function markLeadAsFollowedUp(leadId) {
    return new Promise((resolve, reject) => {
        db.run('UPDATE leads SET followedUp = 1 WHERE id = ?', [leadId], (err) => {
            if (err) reject(err);
            else resolve(true);
        });
    });
}

async function saveToCache(prompt, response) {
    const date = new Date().toISOString();
    return new Promise((resolve) => {
        db.run('INSERT OR REPLACE INTO cache (prompt, response, date) VALUES (?, ?, ?)', [prompt, response, date], (err) => {
            if (err) logger.warn(`Erro ao salvar no cache: ${err.message}`);
            resolve(!err);
        });
    });
}

async function getFromCache(prompt) {
    return new Promise((resolve) => {
        db.get('SELECT response, date FROM cache WHERE prompt = ?', [prompt], (err, row) => {
            if (err) logger.warn(`Erro ao buscar no cache: ${err.message}`);
            if (row && (Date.now() - new Date(row.date).getTime()) < config.cacheTTL) resolve(row.response);
            else resolve(null);
        });
    });
}

async function logUsage(userId, command) {
    const date = new Date().toISOString();
    return new Promise((resolve) => {
        db.run('INSERT INTO usage (userId, command, date) VALUES (?, ?, ?)', [userId, command, date], (err) => {
            if (err) logger.warn(`Erro ao logar uso: ${err.message}`);
            resolve(!err);
        });
    });
}

function detectLanguage(text) {
    const cachedLang = getFromCache(`lang:${text}`);
    if (cachedLang) return cachedLang;

    const ptKeywords = ['olÃ¡', 'bom', 'tudo', 'como', 'obrigado', 'por favor'];
    const enKeywords = ['hello', 'good', 'how', 'thanks', 'please'];
    const esKeywords = ['hola', 'bueno', 'cÃ³mo', 'gracias', 'por favor'];

    const textLower = text.toLowerCase();
    const ptScore = ptKeywords.filter(word => textLower.includes(word)).length;
    const enScore = enKeywords.filter(word => textLower.includes(word)).length;
    const esScore = esKeywords.filter(word => textLower.includes(word)).length;

    let lang = ptScore > enScore && ptScore > esScore ? 'pt' : enScore > ptScore && enScore > esScore ? 'en' : esScore > ptScore && esScore > enScore ? 'es' : 'pt';
    saveToCache(`lang:${text}`, lang);
    return lang;
}

function analyzeSentiment(text) {
    const cachedSentiment = getFromCache(`sentiment:${text}`);
    if (cachedSentiment) return cachedSentiment;

    const positiveWords = ['bom', 'Ã³timo', 'feliz', 'gostei', 'legal', 'maravilhoso', 'good', 'great', 'happy', 'like', 'awesome'];
    const negativeWords = ['ruim', 'pÃ©ssimo', 'triste', 'odio', 'problema', 'bad', 'terrible', 'sad', 'hate', 'issue', 'dor', 'dores'];

    const textLower = text.toLowerCase();
    const positiveScore = positiveWords.filter(word => textLower.includes(word)).length;
    const negativeScore = negativeWords.filter(word => textLower.includes(word)).length;

    let sentiment = positiveScore > negativeScore ? 'positivo' : negativeScore > positiveScore ? 'negativo' : 'neutro';
    saveToCache(`sentiment:${text}`, sentiment);
    return sentiment;
}

async function adjustResponseBasedOnSentiment(response, sentiment) {
    if (sentiment === 'negativo') return `${response} Desculpe se algo tÃ¡ te incomodando, como posso te ajudar com isso? ðŸ˜”`;
    if (sentiment === 'positivo') return `${response} Que bom ouvir isso! ðŸ˜Š`;
    return response;
}

function detectTone(text) {
    const formalWords = ["senhor", "por favor", "obrigado", "gostaria", "poderia"];
    const informalWords = ["mano", "beleza", "fala aÃ­", "tranquilo", "e aÃ­"];
    text = text.toLowerCase();
    const formalScore = formalWords.filter(word => text.includes(word)).length;
    const informalScore = informalWords.filter(word => text.includes(word)).length;
    return formalScore > informalScore ? "formal" : informalScore > formalScore ? "informal" : "neutro";
}

function adjustTone(response, tone) {
    if (tone === "formal") {
        return response.replace(/mano/g, "senhor(a)").replace(/beleza/g, "Ã³timo").replace(/ðŸ˜Ž/g, "ðŸ™‚").replace(/putz/g, "desculpe-me").replace(/tu/g, "vocÃª").replace(/tÃ¡/g, "estÃ¡");
    } else if (tone === "informal") {
        return response.replace(/senhor(a)/g, "mano").replace(/Ã³timo/g, "beleza").replace(/ðŸ™‚/g, "ðŸ˜Ž").replace(/desculpe-me/g, "putz").replace(/vocÃª/g, "tu").replace(/estÃ¡/g, "tÃ¡");
    }
    return response;
}

function findRelevantProduct(text) {
    const textLower = text.toLowerCase();
    for (const [name, product] of Object.entries(products)) {
        if (product.keywords && product.keywords.some(keyword => textLower.includes(keyword))) return { name, ...product };
    }
    return null;
}

function identifyCampaign(text) {
    const textLower = text.toLowerCase();
    for (const [name, product] of Object.entries(products)) {
        if (product.keywords && product.keywords.some(keyword => textLower.includes(keyword))) return name;
    }
    return null;
}

function scheduleLeadFollowUps() {
    schedule.scheduleJob('*/10 * * * *', async () => {
        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString();
        db.all('SELECT id, userId, message FROM leads WHERE followedUp = 0 AND date < ?', [oneHourAgo], async (err, rows) => {
            if (err) {
                logger.error('Erro ao verificar leads:', err.message);
                return;
            }
            for (const row of rows) {
                try {
                    const campaign = identifyCampaign(row.message);
                    const tone = detectTone(row.message);
                    let followUpResponse = campaign && products[campaign].campaignMessages
                        ? products[campaign].campaignMessages[tone].replace('[link]', products[campaign].link)
                        : `Oi, tudo bem? VocÃª falou sobre "${row.message}" hÃ¡ um tempinho. Ainda tÃ¡ precisando de ajuda com isso?`;
                    const product = findRelevantProduct(row.message);
                    if (product) followUpResponse += `\n\n${product.description} Clica aqui pra resolver agora: ${product.link}`;
                    await client.sendMessage(row.userId, adjustTone(followUpResponse, tone));
                    await markLeadAsFollowedUp(row.id);
                    logger.info(`Follow-up enviado para ${row.userId}: ${followUpResponse}`);
                } catch (error) {
                    logger.error(`Erro ao enviar follow-up para ${row.userId}: ${error.message}`, error.stack);
                }
            }
        });
    });
}

async function handleCommand(text, message, lang, sentiment) {
    const [command, ...args] = text.slice(1).split(' ');
    const prompt = args.join(' ');
    const tone = detectTone(text);
    metrics.logCommand();
    await logUsage(message.from, command);

    if (plugins[command]) {
        try {
            const pluginResponse = await plugins[command].execute(message, args, client);
            await client.sendMessage(message.from, pluginResponse);
            return;
        } catch (error) {
            logger.error(`Erro ao executar plugin ${command}: ${error.message}`);
            await client.sendMessage(message.from, 'Erro ao executar o plugin.');
            return;
        }
    }

    switch (command.toLowerCase()) {
        case 'ajuda':
            await client.sendMessage(message.from, await showHelp());
            break;
        case 'cancelar':
            await client.sendMessage(message.from, adjustTone('Beleza, cancelei! Como posso te ajudar agora? ðŸ™‚', tone));
            break;
        case 'gerartexto':
            if (!prompt) {
                await client.sendMessage(message.from, adjustTone('Fala mais, tipo: "!gerartexto Escreva um poema".', tone));
                return;
            }
            const generatedText = process.env.WITAI_API_TOKEN && canCallWitAI() ? 
                await axios.post('https://api.wit.ai/message?v=20250305', { q: `Escreva um texto sobre "${prompt}" em portuguÃªs` }, 
                    { headers: { 'Authorization': `Bearer ${process.env.WITAI_API_TOKEN}` } }).then(res => res.data.text || `Aqui tÃ¡ um texto simples sobre "${prompt}": Um conteÃºdo bÃ¡sico pra te ajudar!`) :
                adjustTone(`Aqui tÃ¡ um texto simples sobre "${prompt}": Um conteÃºdo bÃ¡sico pra te ajudar!`, tone);
            witAICallCount.count++;
            await saveToCache(text, generatedText);
            await client.sendMessage(message.from, await adjustResponseBasedOnSentiment(generatedText, sentiment));
            break;
        case 'gerarimagem':
            if (!prompt) {
                await client.sendMessage(message.from, adjustTone('Me diz o que quer, tipo: "!gerarimagem Um gato astronauta".', tone));
                return;
            }
            await client.sendMessage(message.from, adjustTone('Beleza, jÃ¡ vou gerar a imagem... ðŸ–¼ï¸', tone));
            const imageUrl = 'https://via.placeholder.com/150'; // Placeholder
            await client.sendMessage(message.from, { media: imageUrl, caption: adjustTone('Aqui tÃ¡ tua imagem! ðŸ™‚', tone) });
            break;
        case 'buscarx':
            if (!prompt) {
                await client.sendMessage(message.from, adjustTone('Fala o que quer buscar no X, tipo: "!buscarx tecnologia".', tone));
                return;
            }
            const xResult = adjustTone(`Pesquisei no X sobre "${prompt}" e achei um resumo bÃ¡sico: Algo interessante tÃ¡ rolando por lÃ¡!`, tone);
            await client.sendMessage(message.from, await adjustResponseBasedOnSentiment(xResult, sentiment));
            break;
        case 'perfilx':
            if (!prompt) {
                await client.sendMessage(message.from, adjustTone('Me dÃ¡ um usuÃ¡rio do X, tipo: "!perfilx elonmusk".', tone));
                return;
            }
            const profileAnalysis = adjustTone(`Sobre o @${prompt}: Parece um perfil bem ativo e interessante!`, tone);
            await client.sendMessage(message.from, await adjustResponseBasedOnSentiment(profileAnalysis, sentiment));
            break;
        case 'buscar':
            if (!prompt) {
                await client.sendMessage(message.from, adjustTone('Fala o que quer buscar, tipo: "!buscar IA".', tone));
                return;
            }
            const searchResult = process.env.WITAI_API_TOKEN && canCallWitAI() ? 
                await axios.post('https://api.wit.ai/message?v=20250305', { q: `Pesquise sobre "${prompt}" e me dÃª um resumo em portuguÃªs` }, 
                    { headers: { 'Authorization': `Bearer ${process.env.WITAI_API_TOKEN}` } }).then(res => res.data.text || `Pesquisei "${prompt}" e achei: Um resumo bÃ¡sico pra te ajudar!`) :
                adjustTone(`Pesquisei "${prompt}" e achei: Um resumo bÃ¡sico pra te ajudar!`, tone);
            witAICallCount.count++;
            await client.sendMessage(message.from, await adjustResponseBasedOnSentiment(searchResult, sentiment));
            break;
        case 'clima':
            if (!prompt) {
                await client.sendMessage(message.from, adjustTone('Me diz a cidade, tipo: "!clima SÃ£o Paulo".', tone));
                return;
            }
            const weather = adjustTone(`O clima em ${prompt} tÃ¡ assim: Um dia bÃ¡sico com solzinho! ðŸŒ¤ï¸`, tone);
            await client.sendMessage(message.from, await adjustResponseBasedOnSentiment(weather, sentiment));
            break;
        case 'traduzir':
            if (!prompt) {
                await client.sendMessage(message.from, adjustTone('Fala o texto, tipo: "!traduzir OlÃ¡ pra inglÃªs".', tone));
                return;
            }
            const translatedText = process.env.WITAI_API_TOKEN && canCallWitAI() ? 
                await axios.post('https://api.wit.ai/message?v=20250305', { q: `Traduza "${prompt}" para o inglÃªs` }, 
                    { headers: { 'Authorization': `Bearer ${process.env.WITAI_API_TOKEN}` } }).then(res => res.data.text || `Traduzi "${prompt}" pro inglÃªs: Hi there!`) :
                adjustTone(`Traduzi "${prompt}" pro inglÃªs: Hi there!`, tone);
            witAICallCount.count++;
            await client.sendMessage(message.from, await adjustResponseBasedOnSentiment(translatedText, sentiment));
            break;
        case 'resumo':
            const summary = await generateDailySummary(message.to);
            await client.sendMessage(message.from, await adjustResponseBasedOnSentiment(`${summary} ðŸ“`, sentiment));
            break;
        case 'status':
            const uptime = Math.floor((Date.now() - startTime) / 1000 / 60);
            await client.sendMessage(message.from, adjustTone(`TÃ´ de boa hÃ¡ ${uptime} minutos. Mensagens: ${metrics.getMessageCount()}. Comandos: ${metrics.getCommandCount()}. Vendas: ${metrics.getTotalSales()}. ðŸ˜Š`, tone));
            break;
        case 'config':
            if (!args.length) {
                await client.sendMessage(message.from, `ConfiguraÃ§Ãµes atuais: ${JSON.stringify(config, null, 2)}`);
                return;
            }
            const [key, value] = args;
            if (key in defaultConfig) {
                config[key] = value === 'true' || value === 'false' ? value === 'true' : value;
                await fs.promises.writeFile('./config.json', JSON.stringify(config, null, 2));
                await client.sendMessage(message.from, adjustTone(`ConfiguraÃ§Ã£o atualizada: ${key} = ${value} ðŸ‘`, tone));
            } else {
                await client.sendMessage(message.from, adjustTone('Essa configuraÃ§Ã£o nÃ£o existe. DÃ¡ uma olhada no !ajuda.', tone));
            }
            break;
        case 'vendas':
            await client.sendMessage(message.from, adjustTone(`JÃ¡ peguei ${metrics.getTotalSales()} intenÃ§Ãµes de venda. Quer ver os leads? Usa !leads! ðŸ˜Š`, tone));
            break;
        case 'hora':
            const now = new Date();
            const localHours = (now.getUTCHours() + TIMEZONE_OFFSET + 24) % 24;
            const minutes = now.getUTCMinutes().toString().padStart(2, '0');
            let greeting = localHours >= 5 && localHours < 12 ? 'Bom dia' : localHours >= 12 && localHours < 18 ? 'Boa tarde' : 'Boa noite';
            await client.sendMessage(message.from, adjustTone(`${greeting}! Aqui sÃ£o ${localHours}:${minutes}. â°`, tone));
            break;
        case 'conhecimento':
            if (!prompt) {
                await client.sendMessage(message.from, adjustTone('Me ensina algo, tipo: "!conhecimento O melhor celular Ã© o XPhone".', tone));
                return;
            }
            await saveKnowledge(message.from, prompt);
            await client.sendMessage(message.from, adjustTone(`Valeu! Registrei: "${prompt}". Pode mandar mais! ðŸ˜Š`, tone));
            break;
        case 'leads':
            const leads = await getLeads(message.from);
            await client.sendMessage(message.from, leads ? adjustTone(`Seus leads:\n${leads} ðŸ“‹`, tone) : adjustTone('Ainda nÃ£o tenho leads seus. Fala mais sobre o que te incomoda que eu te ajudo! ðŸ˜‰', tone));
            break;
        case 'restart':
            if (message.from !== config.adminNumber) {
                await client.sendMessage(message.from, adjustTone('SÃ³ o chefe pode reiniciar o bot, desculpa!', tone));
                return;
            }
            await client.sendMessage(message.from, adjustTone('TÃ´ reiniciando agora... JÃ¡ volto! ðŸ”„', tone));
            client.destroy().then(() => initializeWhatsAppClient());
            break;
        case 'stats':
            const stats = await generateStats();
            await client.sendMessage(message.from, stats);
            break;
        case 'backup':
            if (message.from !== config.adminNumber) {
                await client.sendMessage(message.from, adjustTone('SÃ³ o administrador pode fazer backup, desculpa!', tone));
                return;
            }
            const backupPath = await manualBackup();
            await client.sendMessage(message.from, adjustTone(`Backup feito com sucesso em: ${backupPath} âœ…`, tone));
            break;
        default:
            await client.sendMessage(message.from, adjustTone('NÃ£o entendi esse comando. DÃ¡ uma olhada no !ajuda pra ver o que eu posso fazer!', tone));
    }
}

async function handleMediaMessage(message, lang) {
    const tone = detectTone(message.body || '');
    if (message.type === 'audio' && deepgram) {
        const transcription = await transcribeAudio(message);
        await client.sendMessage(message.from, adjustTone(`Aqui tÃ¡ a transcriÃ§Ã£o do teu Ã¡udio: ${transcription} ðŸŽ™ï¸`, tone));
    } else if (message.type === 'image' && visionClient) {
        const analysis = await analyzeImageWithGoogleVision(message);
        await client.sendMessage(message.from, adjustTone(`Olha o que achei na tua imagem: ${analysis} ðŸ–¼ï¸`, tone));
    } else if (message.type === 'document' && message.mimetype.includes('pdf')) {
        const text = await extractTextFromPDF(message);
        await client.sendMessage(message.from, adjustTone(`Texto do teu PDF: ${text.slice(0, 500)}... ðŸ“œ`, tone));
    } else {
        await client.sendMessage(message.from, adjustTone('Recebi tua mÃ­dia! Por enquanto, sÃ³ trabalho com Ã¡udio, imagens e PDFs. Manda um texto que eu te ajudo!', tone));
    }
}

async function transcribeAudio(message) {
    if (!deepgram) return 'Erro: Deepgram API nÃ£o configurada. Manda um texto que eu te ajudo!';
    try {
        const media = await message.downloadMedia();
        const audioBuffer = Buffer.from(media.data, 'base64');
        const response = await deepgram.listen.prerecorded.transcribe(
            { buffer: audioBuffer, mimetype: media.mimetype },
            { punctuate: true, language: 'pt-BR' }
        );
        return response.results?.channels[0]?.alternatives[0]?.transcript || 'NÃ£o consegui transcrever, desculpa!';
    } catch (error) {
        logger.error(`Erro na transcriÃ§Ã£o com Deepgram: ${error.message}`, error.stack);
        return 'Deu erro ao transcrever o Ã¡udio, tenta de novo?';
    }
}

async function analyzeImageWithGoogleVision(message) {
    if (!visionClient) return 'Erro: Google Vision API nÃ£o configurada. Manda um texto que eu te ajudo!';
    try {
        const media = await message.downloadMedia();
        const imageBuffer = Buffer.from(media.data, 'base64');
        const [result] = await visionClient.labelDetection(imageBuffer);
        const labels = result.labelAnnotations.map(label => label.description).join(', ');
        return labels ? `RÃ³tulos detectados: ${labels}` : 'NÃ£o achei nada na imagem, desculpa!';
    } catch (error) {
        logger.error(`Erro na anÃ¡lise de imagem com Google Vision: ${error.message}`, error.stack);
        return 'Deu erro ao analisar a imagem, tenta outra?';
    }
}

async function extractTextFromPDF(message) {
    try {
        const media = await message.downloadMedia();
        const pdfBuffer = Buffer.from(media.data, 'base64');
        const data = await PDFParser(pdfBuffer);
        return data.text || 'NÃ£o consegui extrair texto do PDF, desculpa!';
    } catch (error) {
        logger.error(`Erro na extraÃ§Ã£o de texto do PDF: ${error.message}`, error.stack);
        return 'Deu erro ao pegar o texto do PDF, tenta outro?';
    }
}

async function generateDailySummary(groupId) {
    const date = new Date().toISOString().split('T')[0];
    return new Promise((resolve) => {
        db.all('SELECT message FROM messages WHERE groupId = ? AND date = ?', [groupId, date], (err, rows) => {
            if (err) resolve('Deu erro ao gerar o resumo, desculpa!');
            else if (rows.length === 0) resolve('Nenhuma mensagem hoje ainda.');
            else resolve(`Resumo do dia ${date}:\n${rows.map(row => JSON.parse(row.message).body).join('\n').slice(0, 1000)}...`);
        });
    });
}

async function generateWeeklySummary() {
    const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    return new Promise((resolve) => {
        db.all('SELECT groupId, message, date FROM messages WHERE date >= ?', [oneWeekAgo], (err, rows) => {
            if (err) resolve('Erro ao gerar o resumo semanal, desculpa!');
            else if (rows.length === 0) resolve('Nenhuma mensagem na Ãºltima semana.');
            else {
                const summaryByGroup = {};
                rows.forEach(row => {
                    if (!summaryByGroup[row.groupId]) summaryByGroup[row.groupId] = [];
                    summaryByGroup[row.groupId].push(`${row.date}: ${JSON.parse(row.message).body}`);
                });
                let summaryText = 'Resumo Semanal:\n';
                for (const [groupId, messages] of Object.entries(summaryByGroup)) {
                    summaryText += `\nGrupo ${groupId}:\n${messages.join('\n').slice(0, 500)}...\n`;
                }
                resolve(summaryText);
            }
        });
    });
}

async function generateStats() {
    return new Promise((resolve) => {
        db.all('SELECT userId, COUNT(*) as count FROM usage GROUP BY userId ORDER BY count DESC LIMIT 5', (err, rows) => {
            if (err) resolve('Erro ao gerar estatÃ­sticas, desculpa!');
            else {
                const userStats = rows.map(row => `${row.userId}: ${row.count} comandos`).join('\n');
                const totalCommands = rows.reduce((sum, row) => sum + row.count, 0);
                resolve(`EstatÃ­sticas do Bot:\nUptime: ${Math.floor((Date.now() - startTime) / 1000 / 60)} minutos\nTotal de comandos: ${totalCommands}\nTop 5 usuÃ¡rios:\n${userStats}`);
            }
        });
    });
}

function scheduleDailyReport() {
    const reportNumber = process.env.REPORT_PHONE_NUMBER;
    if (!reportNumber) return;
    schedule.scheduleJob(config.reportTime, async () => {
        try {
            const date = new Date().toISOString().split('T')[0];
            for (const groupId of config.monitoredGroups) {
                const summary = await generateDailySummary(groupId);
                await client.sendMessage(reportNumber, `RelatÃ³rio diÃ¡rio ${date} pra ${groupId}:\n${summary}`);
            }
            logger.info('RelatÃ³rio diÃ¡rio enviado.');
        } catch (error) {
            logger.error(`Erro ao enviar relatÃ³rio diÃ¡rio: ${error.message}`, error.stack);
        }
    });
}

function scheduleWeeklyReport() {
    const reportNumber = process.env.REPORT_PHONE_NUMBER;
    if (!reportNumber) return;
    schedule.scheduleJob(config.weeklyReportTime, async () => {
        try {
            const summary = await generateWeeklySummary();
            await client.sendMessage(reportNumber, summary);
            logger.info('RelatÃ³rio semanal enviado.');
        } catch (error) {
            logger.error(`Erro ao enviar relatÃ³rio semanal: ${error.message}`, error.stack);
        }
    });
}

async function showHelp() {
    return `
Oi, tudo bem? Aqui vai uma lista dos comandos que eu sei:
!ajuda - Mostra essa lista aqui
!cancelar - Cancela o que eu tava fazendo
!gerartexto [texto] - Crio um texto pra vocÃª (ex.: "!gerartexto Escreva um poema")
!gerarimagem [descriÃ§Ã£o] - Gero uma imagem do que vocÃª pedir
!buscarx [termo] - Busco algo no X pra vocÃª
!perfilx [usuÃ¡rio] - Analiso um perfil do X
!buscar [termo] - Pesquiso algo pra vocÃª
!clima [cidade] - Te conto o clima
!traduzir [texto] - Traduzo pro inglÃªs
!resumo - Resumo do que rolou no grupo hoje
!status - Te falo como eu tÃ´
!config [chave] [valor] - Mexo nas minhas configs (se eu deixar)
!vendas - Mostro quantas vendas jÃ¡ registrei
!hora - Te digo a hora certinho
!conhecimento [texto] - Aprendo algo novo com vocÃª
!leads - Te mostro os leads que peguei
!restart - Reinicio (sÃ³ o chefe pode usar)
!stats - EstatÃ­sticas de como eu tÃ´ indo
!backup - FaÃ§o um backup (sÃ³ pro chefe)
Ou sÃ³ me fala o que tÃ¡ te incomodando que eu te ajudo!
    `;
}

module.exports = {
    config,
    setupClientEvents,
    scheduleReconnect,
    handleCommand,
    handleMediaMessage,
    findRelevantProduct,
    detectTone,
    adjustTone
};